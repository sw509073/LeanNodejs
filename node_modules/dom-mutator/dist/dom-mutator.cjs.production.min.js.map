{"version":3,"file":"dom-mutator.cjs.production.min.js","sources":["../src/index.ts"],"sourcesContent":["export const validAttributeName = /^[a-zA-Z:_][a-zA-Z0-9:_.-]*$/;\nconst nullController: MutationController = {\n  revert: () => {},\n};\n\nconst elements: Map<Element, ElementRecord> = new Map();\nconst mutations: Set<Mutation> = new Set();\n\nfunction getObserverInit(attr: string): MutationObserverInit {\n  return attr === 'html'\n    ? {\n        childList: true,\n        subtree: true,\n        attributes: true,\n        characterData: true,\n      }\n    : {\n        childList: false,\n        subtree: false,\n        attributes: true,\n        attributeFilter: [attr],\n      };\n}\n\nfunction getElementRecord(element: Element): ElementRecord {\n  let record = elements.get(element);\n\n  if (!record) {\n    record = { element, attributes: {} };\n    elements.set(element, record);\n  }\n\n  return record;\n}\n\nfunction createElementPropertyRecord(\n  el: Element,\n  attr: string,\n  getCurrentValue: (el: Element) => any,\n  setValue: (el: Element, val: any) => void,\n  mutationRunner: (record: ElementPropertyRecord<any, any>) => void\n) {\n  const currentValue = getCurrentValue(el);\n  const record: ElementPropertyRecord<any, any> = {\n    isDirty: false,\n    originalValue: currentValue,\n    virtualValue: currentValue,\n    mutations: [],\n    el,\n    observer: new MutationObserver(() => {\n      const currentValue = getCurrentValue(el);\n      if (currentValue === record.virtualValue) return;\n      record.originalValue = currentValue;\n      mutationRunner(record);\n    }),\n    mutationRunner,\n    setValue,\n    getCurrentValue,\n  };\n  record.observer.observe(el, getObserverInit(attr));\n  return record;\n}\n\nfunction queueIfNeeded(\n  val: string | null,\n  record: ElementPropertyRecord<any, any>\n) {\n  const currentVal = record.getCurrentValue(record.el);\n  record.virtualValue = val;\n  if (val !== currentVal) {\n    record.isDirty = true;\n    queueDOMUpdates();\n  }\n}\n\nfunction htmlMutationRunner(record: HTMLRecord) {\n  let val = record.originalValue;\n  record.mutations.forEach(m => (val = m.mutate(val)));\n  queueIfNeeded(getTransformedHTML(val), record);\n}\nfunction classMutationRunner(record: ClassnameRecord) {\n  const val = new Set(record.originalValue.split(/\\s+/).filter(Boolean));\n  record.mutations.forEach(m => m.mutate(val));\n  queueIfNeeded(\n    Array.from(val)\n      .filter(Boolean)\n      .join(' '),\n    record\n  );\n}\nfunction attrMutationRunner(record: AttributeRecord) {\n  let val: string | null = record.originalValue;\n  record.mutations.forEach(m => (val = m.mutate(val)));\n  queueIfNeeded(val, record);\n}\n\nconst getHTMLValue = (el: Element) => el.innerHTML;\nconst setHTMLValue = (el: Element, value: string) => (el.innerHTML = value);\nfunction getElementHTMLRecord(element: Element): HTMLRecord {\n  const elementRecord = getElementRecord(element);\n  if (!elementRecord.html) {\n    elementRecord.html = createElementPropertyRecord(\n      element,\n      'html',\n      getHTMLValue,\n      setHTMLValue,\n      htmlMutationRunner\n    );\n  }\n  return elementRecord.html;\n}\n\nconst setClassValue = (el: Element, val: string) =>\n  val ? (el.className = val) : el.removeAttribute('class');\nconst getClassValue = (el: Element) => el.className;\nfunction getElementClassRecord(el: Element): ClassnameRecord {\n  const elementRecord = getElementRecord(el);\n  if (!elementRecord.classes) {\n    elementRecord.classes = createElementPropertyRecord(\n      el,\n      'class',\n      getClassValue,\n      setClassValue,\n      classMutationRunner\n    );\n  }\n  return elementRecord.classes;\n}\n\nconst getAttrValue = (attrName: string) => (el: Element) =>\n  el.getAttribute(attrName) ?? null;\nconst setAttrValue = (attrName: string) => (el: Element, val: string | null) =>\n  val !== null ? el.setAttribute(attrName, val) : el.removeAttribute(attrName);\nfunction getElementAttributeRecord(el: Element, attr: string): AttributeRecord {\n  const elementRecord = getElementRecord(el);\n  if (!elementRecord.attributes[attr]) {\n    elementRecord.attributes[attr] = createElementPropertyRecord(\n      el,\n      attr,\n      getAttrValue(attr),\n      setAttrValue(attr),\n      attrMutationRunner\n    );\n  }\n  return elementRecord.attributes[attr];\n}\n\nfunction deleteElementPropertyRecord(el: Element, attr: string) {\n  const element = elements.get(el);\n  if (!element) return;\n  if (attr === 'html') {\n    element.html?.observer?.disconnect();\n    delete element.html;\n  } else if (attr === 'class') {\n    element.classes?.observer?.disconnect();\n    delete element.classes;\n  } else {\n    element.attributes?.[attr]?.observer?.disconnect();\n    delete element.attributes[attr];\n  }\n}\n\nlet transformContainer: HTMLDivElement;\nfunction getTransformedHTML(html: string) {\n  if (!transformContainer) {\n    transformContainer = document.createElement('div');\n  }\n  transformContainer.innerHTML = html;\n  return transformContainer.innerHTML;\n}\n\nfunction setPropertyValue<T extends ElementPropertyRecord<any, any>>(\n  el: Element,\n  attr: string,\n  m: T\n) {\n  if (!m.isDirty) return;\n  m.isDirty = false;\n  const val = m.virtualValue;\n  if (!m.mutations.length) {\n    deleteElementPropertyRecord(el, attr);\n  }\n  m.setValue(el, val);\n}\n\nlet raf = false;\n\nfunction setValue(m: ElementRecord, el: Element) {\n  m.html && setPropertyValue<HTMLRecord>(el, 'html', m.html);\n  m.classes && setPropertyValue<ClassnameRecord>(el, 'class', m.classes);\n  Object.keys(m.attributes).forEach(attr => {\n    setPropertyValue<AttributeRecord>(el, attr, m.attributes[attr]);\n  });\n}\nfunction setValues() {\n  raf = false;\n  elements.forEach(setValue);\n}\nfunction queueDOMUpdates() {\n  if (!raf) {\n    raf = true;\n    requestAnimationFrame(setValues);\n  }\n}\n\n// find or create ElementPropertyRecord, add mutation to it, then run\nfunction startMutating(mutation: Mutation, element: Element) {\n  let record: ElementPropertyRecord<any, any> | null = null;\n  if (mutation.kind === 'html') {\n    record = getElementHTMLRecord(element);\n  } else if (mutation.kind === 'class') {\n    record = getElementClassRecord(element);\n  } else if (mutation.kind === 'attribute') {\n    record = getElementAttributeRecord(element, mutation.attribute);\n  }\n  if (!record) return;\n  record.mutations.push(mutation);\n  record.mutationRunner(record);\n}\n\n// get (existing) ElementPropertyRecord, remove mutation from it, then run\nfunction stopMutating(mutation: Mutation, el: Element) {\n  let record: ElementPropertyRecord<any, any> | null = null;\n  if (mutation.kind === 'html') {\n    record = getElementHTMLRecord(el);\n  } else if (mutation.kind === 'class') {\n    record = getElementClassRecord(el);\n  } else if (mutation.kind === 'attribute') {\n    record = getElementAttributeRecord(el, mutation.attribute);\n  }\n  if (!record) return;\n  const index = record.mutations.indexOf(mutation);\n  if (index !== -1) record.mutations.splice(index, 1);\n  record.mutationRunner(record);\n}\n\n// maintain list of elements associated with mutation\nfunction refreshElementsSet(mutation: Mutation) {\n  const existingElements = new Set(mutation.elements);\n  const newElements: Set<Element> = new Set();\n  const matchingElements = document.querySelectorAll(mutation.selector);\n\n  matchingElements.forEach(el => {\n    newElements.add(el);\n    if (!existingElements.has(el)) {\n      mutation.elements.add(el);\n      startMutating(mutation, el);\n    }\n  });\n\n  existingElements.forEach(el => {\n    if (!newElements.has(el)) {\n      mutation.elements.delete(el);\n      stopMutating(mutation, el);\n    }\n  });\n}\n\nfunction revertMutation(mutation: Mutation) {\n  mutation.elements.forEach(el => stopMutating(mutation, el));\n  mutation.elements.clear();\n  mutations.delete(mutation);\n}\n\nfunction refreshAllElementSets() {\n  mutations.forEach(refreshElementsSet);\n}\n\n// Observer for elements that don't exist in the DOM yet\nlet observer: MutationObserver;\nexport function disconnectGlobalObserver() {\n  observer && observer.disconnect();\n}\nexport function connectGlobalObserver() {\n  if (typeof document === 'undefined') return;\n\n  if (!observer) {\n    observer = new MutationObserver(() => {\n      refreshAllElementSets();\n    });\n  }\n\n  refreshAllElementSets();\n  observer.observe(document.documentElement, {\n    childList: true,\n    subtree: true,\n    attributes: false,\n    characterData: false,\n  });\n}\n\n// run on init\nconnectGlobalObserver();\n\nfunction newMutation(m: Mutation): MutationController {\n  // Not in a browser\n  if (typeof document === 'undefined') return nullController;\n  // add to global index of mutations\n  mutations.add(m);\n  // run refresh on init to establish list of elements associated w/ mutation\n  refreshElementsSet(m);\n  return {\n    revert: () => {\n      revertMutation(m);\n    },\n  };\n}\n\nfunction html(\n  selector: HTMLMutation['selector'],\n  mutate: HTMLMutation['mutate']\n) {\n  return newMutation({\n    kind: 'html',\n    elements: new Set(),\n    mutate,\n    selector,\n  });\n}\n\nfunction classes(\n  selector: ClassnameMutation['selector'],\n  mutate: ClassnameMutation['mutate']\n) {\n  return newMutation({\n    kind: 'class',\n    elements: new Set(),\n    mutate,\n    selector,\n  });\n}\n\nfunction attribute(\n  selector: AttrMutation['selector'],\n  attribute: AttrMutation['attribute'],\n  mutate: AttrMutation['mutate']\n) {\n  if (!validAttributeName.test(attribute)) return nullController;\n\n  if (attribute === 'class' || attribute === 'className') {\n    return classes(selector, classnames => {\n      const mutatedClassnames = mutate(Array.from(classnames).join(' '));\n      classnames.clear();\n      if (!mutatedClassnames) return;\n      mutatedClassnames\n        .split(/\\s+/g)\n        .filter(Boolean)\n        .forEach(c => classnames.add(c));\n    });\n  }\n\n  return newMutation({\n    kind: 'attribute',\n    attribute,\n    elements: new Set(),\n    mutate,\n    selector,\n  });\n}\n\nfunction declarative({\n  selector,\n  action,\n  value,\n  attribute: attr,\n}: DeclarativeMutation): MutationController {\n  if (attr === 'html') {\n    if (action === 'append') {\n      return html(selector, val => val + (value ?? ''));\n    } else if (action === 'set') {\n      return html(selector, () => value ?? '');\n    }\n  } else if (attr === 'class') {\n    if (action === 'append') {\n      return classes(selector, val => {\n        if (value) val.add(value);\n      });\n    } else if (action === 'remove') {\n      return classes(selector, val => {\n        if (value) val.delete(value);\n      });\n    } else if (action === 'set') {\n      return classes(selector, val => {\n        val.clear();\n        if (value) val.add(value);\n      });\n    }\n  } else {\n    if (action === 'append') {\n      return attribute(selector, attr, val =>\n        val !== null ? val + (value ?? '') : value ?? ''\n      );\n    } else if (action === 'set') {\n      return attribute(selector, attr, () => value ?? '');\n    } else if (action === 'remove') {\n      return attribute(selector, attr, () => null);\n    }\n  }\n  return nullController;\n}\n\nexport type MutationController = {\n  revert: () => void;\n};\n\nexport type DeclarativeMutation = {\n  selector: string;\n  attribute: string;\n  action: 'append' | 'set' | 'remove';\n  value?: string;\n};\n\nexport default {\n  html,\n  classes,\n  attribute,\n  declarative,\n};\n"],"names":["validAttributeName","nullController","revert","elements","Map","mutations","Set","getElementRecord","element","record","get","set","attributes","createElementPropertyRecord","el","attr","getCurrentValue","setValue","mutationRunner","currentValue","isDirty","originalValue","virtualValue","observer","MutationObserver","observe","childList","subtree","characterData","attributeFilter","getObserverInit","queueIfNeeded","val","currentVal","raf","requestAnimationFrame","setValues","htmlMutationRunner","forEach","m","mutate","html","transformContainer","document","createElement","innerHTML","getTransformedHTML","classMutationRunner","split","filter","Boolean","Array","from","join","attrMutationRunner","getHTMLValue","setHTMLValue","value","getElementHTMLRecord","elementRecord","setClassValue","className","removeAttribute","getClassValue","getElementClassRecord","classes","getElementAttributeRecord","attrName","getAttribute","setAttribute","setAttrValue","setPropertyValue","length","disconnect","deleteElementPropertyRecord","Object","keys","stopMutating","mutation","kind","attribute","index","indexOf","splice","refreshElementsSet","existingElements","newElements","querySelectorAll","selector","add","has","push","startMutating","refreshAllElementSets","connectGlobalObserver","documentElement","newMutation","clear","test","classnames","mutatedClassnames","c","declarative","action"],"mappings":"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"}